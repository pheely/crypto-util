buildscript {
    ext {
        jupiterVersion = '5.10.2'
        mockitoVersion = '5.6.0'
        lombokVersion = '1.18.26'
    }
}

plugins {
    id 'application'
    id 'eclipse'
    id 'idea'
    id "jacoco"
    id 'maven-publish'
    id 'org.springframework.boot' version '3.2.4'
    id 'io.spring.dependency-management' version '1.0.15.RELEASE'
}

group = 'hstcld'
description 'crypto-utils'
version = ''

jar.enabled = false;

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

tasks.withType(JavaCompile).configureEach {
    // Add additional jvm argument
    options.compilerArgs = ['-Xlint:all']
    options.encoding = 'UTF-8'
}

configurations {
    all {
        exclude group: 'org.apache.logging.log4j', module: 'log4j-to-slf4j'
    }
}

dependencies {
    compileOnly "org.projectlombok:lombok:$lombokVersion"
    annotationProcessor "org.projectlombok:lombok:$lombokVersion"
    implementation group: 'com.google.guava', name: 'guava', version: '30.1.1-jre'
    implementation('org.springframework.boot:spring-boot-starter'){
        exclude group: 'org.apache.logging.log4j', module: 'log4j-to-slf4j'
    }
    implementation 'org.springframework.boot:spring-boot-starter-web'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

repositories {
//    maven {
//        url "${artifactory_contextUrl}/local-gradle-bns"
//        credentials {
//            username = "${artifactory_user}"
//            password = "${artifactory_password}"
//        }
//    }
//    maven {
//        url "${artifactory_contextUrl}/local-release-bns"
//        credentials {
//            username = "${artifactory_user}"
//            password = "${artifactory_password}"
//        }
//    }
//    maven {
//        url "${artifactory_contextUrl}/ext-release-confluent-cache"
//        credentials {
//            username = "${artifactory_user}"
//            password = "${artifactory_password}"
//        }
//    }
//    maven {
//        url "${artifactory_contextUrl}/ext-release-gradle-plugins"
//        credentials {
//            username = "${artifactory_user}"
//            password = "${artifactory_password}"
//        }
//    }
    mavenCentral()
}

tasks.named('bootBuildImage') {
    builder = 'paketobuildpacks/builder-jammy-base:latest'
}

jar {
    enabled = false
}

//tasks.register('generateKeys') {
//    dependsOn ':build'
//
//    doLast {
//        env = project.property('env')
////        println "property: $env"
//
//        def stdout = new ByteArrayOutputStream()
//        exec {
//            commandLine 'sh', 'keyGen.sh', "${env}"
//            standardOutput = stdout
//        }
//        println "$stdout"
//    }
//}

tasks.register('package') {
    dependsOn ':build'

    doLast {
        def stdout = new ByteArrayOutputStream()
        exec {
            commandLine 'rm', '-f', 'keyGen.zip'
        }
        exec {
            workingDir 'keyGen'
            commandLine 'rm', '-f', 'cek-keygenerator.jar'
        }
        exec {
            commandLine 'cp', 'build/libs/cek-keygenerator.jar', 'keyGen'
        }
        exec {
            commandLine 'zip', '-r', 'keyGen.zip', 'keyGen'
            standardOutput = stdout
        }
        println "$stdout"
    }
}

tasks.register('customClean') {
    dependsOn ':clean'
    doLast {
        def stdout = new ByteArrayOutputStream()
        exec {
            commandLine 'rm', '-f', 'keyGen.zip'
            standardOutput = stdout
        }
        println "$stdout"
    }
}

// Configure Jacoco Coverage verification during build process. Sonarqube will also compute and check coverage for the project
def coverageExclusions = [
        // Exclude generated code, domain objects and configuration from coverage reports
        'com/bns/hstcld/utils/CustomEncoder**',
        'com/bns/hstcld/CekEncryptor**'
]

// JaCoCo - Override some of Jacoco default values
jacocoTestReport {
    description 'Generates Code coverage report. Fails build if it does not meet minimum coverage.'

    dependsOn test
    reports {
        xml.enabled = true
        html.enabled = true
        csv.enabled = false
    }
    afterEvaluate {
        def jtrFiles = files(classDirectories.files.collect {
            fileTree(dir: it, exclude: coverageExclusions)
        })
        classDirectories.setFrom(jtrFiles)
    }
}

// coverage ----
jacocoTestCoverageVerification {
    violationRules {
        rule {
            element = 'CLASS'
            limit {
                minimum = 0.8
            }
        }
    }
    afterEvaluate {
        def jtcvFiles = files(classDirectories.files.collect {
            fileTree(dir: it, exclude: coverageExclusions)
        })
        classDirectories.setFrom(jtcvFiles)
    }
}

tasks.named('check').configure {
    dependsOn tasks.named('jacocoTestCoverageVerification')
}

tasks.withType(Jar).configureEach {
    manifest.attributes('Implementation-Title': project.description,
            'Implementation-Version': project.version
    )
}

task(jacocoIntegrationTestReport) {
    group = 'Reporting'
    description = 'Mandatory task because the Jacoco plugin hooks into all test tasks but we do not report coverage on integTest'
/* Generally, we don't bother collecting coverage on Integration tests. If you want it, then you'll have to research how it should be configured
    description = 'Generate Jacoco coverage reports after running integration tests.'
    executionData integrationTest
    sourceDirectories = files(sourceSets.main.java.srcDirs())
    classDirectories = files(sourceSets.main.output.classesDirs)

    reports {
        csv {
            enabled false
        }
        html.destination new File("${buildDir}/reports/jacoco/integrationTest/html")
        xml.destination new File("${buildDir}/reports/jacoco/integrationTest/integrationTestReport.xml")
    }
*/
}
